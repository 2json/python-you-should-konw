### 进程池
当创建的子进程不是很多的时候，我们可以使用multiprocessing模块提供的Process方法来动态的创建多个进程。但是，如果我们需要创建很多子进程的时候，上面这种方式就不太适合。此时，我们就可以通过进程池的方式来创建进程。

创建进程池是通过`multiprocessing.Pool`方法进行创建的。

当我们初始化Pool的时候，我们可以制定一个最大的进程数。当有新的请求提交到Pool中的时候，如果进程池还没有满，那么就可以新建一个子进程用于处理这个请求。但是如果进程池中的进程数量已经达到了指定的最大值，那么这个请求就会等待，直到进程池中有进程结束，才会创建一个新的进程。

下面就是一个借助于进程池创建进程的代码：

```python
from multiprocessing import Pool
import os, time, random

def worker(msg):
    t_start = time.time()
    print '%s开始执行，进程的id为：%d' % (msg, os.getpid())
    # random.random()随机生成0-1之间的浮点数
    time.sleep(random.random() * 2)
    t_stop = time.time()
    print msg, '执行完毕，耗时%0.2f' % (t_stop - t_start)

# 定义一个进程池，最大的进程数是3
pool = Pool(3)

for i in range(0, 10):
    # Pool.apply_async(要调用的目标，(传递给目标的参数元组))
    # 每次循环将会用空闲出来的子进程去调用目标
    pool.apply_async(worker, (i,))

print '-'*5, 'start', '-'*5
pool.close() # 关闭进程池，关闭之后的pool将不会再接受新的请求，也就是不能再添加心得请求了。
pool.join() # 等待pool中所有的子进程执行完成，必须放在close语句，如果没有调用这个，就会导致进程中的任务不会执行，因为主进程会直接退出。
print '-'*5, 'end', '-'*5
```
执行上面程序的结果为

```python
----- start -----
1开始执行，进程的id为：82804
2开始执行，进程的id为：82805
2 执行完毕，耗时0.07
3开始执行，进程的id为：82805
1 执行完毕，耗时0.94
4开始执行，进程的id为：82804
3 执行完毕，耗时1.63
5开始执行，进程的id为：82805
0 执行完毕，耗时1.77
6开始执行，进程的id为：82803
6 执行完毕，耗时0.44
7开始执行，进程的id为：82803
5 执行完毕，耗时0.76
8开始执行，进程的id为：82805
4 执行完毕，耗时1.78
9开始执行，进程的id为：82804
9 执行完毕，耗时0.31
7 执行完毕，耗时1.62
8 执行完毕，耗时1.42
----- end -----
```
从上面的结果可以看出，虽然创建了十个进程，但是pid的值只存在3个。如果添加的任务的数量超过了进程池中进程的个数的话，那么多出的任务就会处于等待的状态，当进程池中的进程完成一个任务的时候，会自动的利用这个进程接着完成下面的任务，知道所有的任务全部完成，进程池才会关闭。

> 